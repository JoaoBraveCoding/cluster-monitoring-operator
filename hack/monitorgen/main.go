// Copyright 2021 The Cluster Monitoring Operator Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	metricsprofiles "github.com/openshift/cluster-monitoring-operator/hack/monitorgen/metrics"
	"github.com/openshift/cluster-monitoring-operator/pkg/manifests"
	"sigs.k8s.io/yaml"

	monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
)

const (
	scrapeProfileLabel = "monitoring.openshift.io/collection-profile"
)

var (
	path            *string
	pathMetricsFile *string
	// Map that contains ServiceMonitor names as keys and a list of metrics as
	// value
	minimalProfileMetrics = map[string][]string{
		"kubelet":            metricsprofiles.KubeletMinimal,
		"etcd":               metricsprofiles.EtcdMinimal,
		"node-exporter":      metricsprofiles.NodeExporterMinimal,
		"kube-state-metrics": metricsprofiles.KubeStateMetricsMinimal,
		"prometheus-adapter": metricsprofiles.PrometheusAdapterMinimal,
	}
)

func init() {
	path = flag.String("path", "./assets/control-plane/service-monitor-kubelet.yaml", "(Required) Path to ServiceMonitor that we want to generate collection profiles")
	pathMetricsFile = flag.String("metrics-file", "", "(Optional) Path to file containing a list of metrics that we want to the ServiceMonitor to Keep.")
}

func main() {

	flag.Parse()

	f, err := os.ReadFile(*path)
	if err != nil {
		log.Fatalf("failed to read asset %v: %e", *path, err)
	}

	m, err := manifests.NewServiceMonitor(bytes.NewReader(f))
	if err != nil {
		log.Fatalf("failed to convert to service monitor: %e", err)
	}

	// The script is only inteded to be used with resources of kind ServiceMonitor
	if m.Kind != "ServiceMonitor" {
		return
	}

	// Don't process ServiceMonitors that were generated by this tool as they will be overwritten
	if val, ok := m.ObjectMeta.Annotations[scrapeProfileLabel]; ok && val != "full" {
		return
	}

	// Get sub set of metrics to keep for the ServiceMonitor name based on the 
	// hard coded value in minimalProfileMetrics 
	metricsToKeep := minimalProfileMetrics[m.ObjectMeta.Name]

	// Overwrite with metrics passed as argument by the user
	if *pathMetricsFile != "" {
		metricsToKeep, err = readMetricsFromFile(*pathMetricsFile)
		if err != nil {
			return
		}
	}

	if len(metricsToKeep) == 0 {
		return
	}

	generateCollectionProfileMinimal(*m, metricsToKeep)
}

// generateCollectionProfileMinimal takes as input a Service Monitor and a set
// of metrics exported by that monitor that we want to keep and generates a
// ServiceMonitor that will only keep those metrics and has the "minimal" collection
// profile label
func generateCollectionProfileMinimal(m monitoringv1.ServiceMonitor, metricsToKeep []string) {
	mMinimal := m.DeepCopy()
	mMinimal.Name = mMinimal.Name + "-minimal"
	mMinimal.Labels[scrapeProfileLabel] = "minimal"
	for i := 0; i < len(mMinimal.Spec.Endpoints); i++ {
		endpoint := &mMinimal.Spec.Endpoints[i]
		// Remove drop relabel configs
		if len(endpoint.MetricRelabelConfigs) > 0 {
			endpoint.MetricRelabelConfigs = removeDropMetricRelableConfigs(endpoint.MetricRelabelConfigs)
		}
		// Add keep relabel configs
		endpoint.MetricRelabelConfigs = append(endpoint.MetricRelabelConfigs, buildRelabelConfig(metricsToKeep))
	}

	yamlData, err := yaml.Marshal(mMinimal)
	if err != nil {
		log.Fatalf("failed marshling monitor: %e", err)
	}

	err = os.WriteFile(builfFileName(*path), yamlData, 0644)
	if err != nil {
		log.Fatalf("Unable to write data into the file: %e", err)
	}
}

// removeDropMetricRelableConfigs goes through metricRelabelConfigs and
// returns a copy of metricRelabelConfigs without relabelConfigs that have the
// action "drop"
func removeDropMetricRelableConfigs(metricRelabelConfigs []*monitoringv1.RelabelConfig) []*monitoringv1.RelabelConfig {
	mrc := make([]*monitoringv1.RelabelConfig, 1)
	for _, relabelConfig := range metricRelabelConfigs {
		if relabelConfig.Action == "drop" {
			continue
		}
		mrc = append(mrc, relabelConfig)
	}

	return mrc
}

// buildRelabelConfig goes through the metrics in the slice metrics and joins
// in a string with "|", them returns a relabelConfig with action "keep" and the
// joined metrics in the regex field.
func buildRelabelConfig(metrics []string) *monitoringv1.RelabelConfig {
	jointMetrics := metrics[0]
	for i := 1; i < len(metrics); i++ {
		jointMetrics = jointMetrics + "|" + metrics[i]
	}

	return &monitoringv1.RelabelConfig{
		Action: "keep",
		SourceLabels: []monitoringv1.LabelName{
			"__name__",
		},
		Regex: fmt.Sprintf("(%s)", jointMetrics),
	}
}

// builfFileName takes a file name like metrics.yaml and add "-minimal" between
// "." and "yaml" resulting in "metrics-minimal.yaml"
func builfFileName(fileName string) string {
	splitedName := strings.Split(fileName, ".")
	return fmt.Sprintf("./%s-minimal.%s", splitedName[len(splitedName)-2], splitedName[len(splitedName)-1])
}

func readMetricsFromFile(path string) ([]string, error) {
	f, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read metrics file: %e", err)
	}
	return strings.Split(string(f), "\n"), nil
}
